---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by WGPavell.
--- DateTime: 22.03.2025 12:29
---

SOUND_INTERFACE_BATTLE_COMPLETED = "_hd.w3mod:UI/Feedback/CheckpointPopup/QuestCheckpoint.flac"
SOUND_INTERFACE_ALL_UNIT_BATTLES_COMPLETED = "Sound/Interface/QuestCompleted.flac"
SOUND_INTERFACE_BATTLE_CONTAINER_APPEAR = "Sound/Interface/QuestActivateWhat1.flac"
SOUND_INTERFACE_ALL_BATTLES_COMPLETED = "Sound/Interface/ClanInvitation.flac"
SOUND_INTERFACE_UNITS_TOPS_APPEAR = "Sound/Interface/ArrangedTeamInvitation.flac"

FOOD_LIMIT = 100
SPAWN_CENTER_DISTANCE = 1500
SPAWN_RADIUS_WIDTH = 1000
SPAWN_RADIUS_HEIGHT = 1500
SPAWN_LEFT = 1
SPAWN_RIGHT = 2

battleUnitsLeft = {
    [SPAWN_LEFT] = 0,
    [SPAWN_RIGHT] = 0
}

battleUnitDefeatTrg = nil
battleUnitHelperSummonTrg = nil
battleUnitTemporaryDisableSpiritFormTrg = nil
battleUnitsGroup = CreateGroup()
sideGroups = {
    [SPAWN_LEFT] = CreateGroup(),
    [SPAWN_RIGHT] = CreateGroup()
}
sideHelperUnits = {}

leftSideSpawnData = {
    raceIndex = 1,
    unitIndex = 1
}
rightSideSpawnData = {
    raceIndex = 1,
    unitIndex = 1
}

sideFrames = nil

battleSideFrames = nil
isWinningFrameAppearing = false

TREE_RESTORE_DELAY = 15.0
TREES_FILTER = Filter(function()
    local destructableType = GetDestructableTypeId(GetFilterDestructable())
    return destructableType == FourCC('LTlt') or destructableType == FourCC('ATtc') or destructableType == FourCC('BTtc')
end)
treeDiesTrg = nil

isCursorEnabled = galse
toggleMouseCursorTrg = nil

function generateGridForSpawn(centerX, angle, unitsTotal)
    local directionDiff = math.cos(math.rad(angle))
    local left = (centerX - (SPAWN_RADIUS_WIDTH / 2)  * directionDiff)
    local bottom = -SPAWN_RADIUS_HEIGHT / 2
    --AddSpecialEffect("Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdl", left, bottom)
    --AddSpecialEffect("Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdl", left, bottom + SPAWN_RADIUS_HEIGHT)
    --AddSpecialEffect("Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdl", left + SPAWN_RADIUS_WIDTH * directionDiff, bottom + SPAWN_RADIUS_HEIGHT)
    --AddSpecialEffect("Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdl", left + SPAWN_RADIUS_WIDTH * directionDiff, bottom)
    local bestCols = math.floor(math.sqrt(unitsTotal))
    if unitsTotal % bestCols ~= 0 then
        bestCols = math.max(math.floor(math.sqrt(unitsTotal * SPAWN_RADIUS_WIDTH / SPAWN_RADIUS_HEIGHT)), 1)
        while unitsTotal % bestCols ~= 0 do
            bestCols = bestCols - 1
        end
    end
    local bestRows = math.floor(unitsTotal / bestCols)
    local dx = bestCols > 1 and SPAWN_RADIUS_WIDTH / (bestCols - 1) * directionDiff or 0
    local dy = bestRows > 1 and SPAWN_RADIUS_HEIGHT / (bestRows - 1) or 0
    local points = {}
    for i = 1, bestRows do
        local y = dy ~= 0 and bottom + (i - 1) * dy or 0
        for j = 1, bestCols do
            local x = dx ~= 0 and left + (j - 1) * dx or centerX
            table.insert(points, {
                x = x,
                y = y
            })
        end
    end
    return points
end

unitsInBattle = {}

---@param unitData table
---@param spawnSide number
function CreateUnitStack(unitData, spawnSide)
    local forPlayer = Player(spawnSide == SPAWN_LEFT and 1 or 2)
    --local forPlayer = Player(0)
    local unitsTotal = math.floor(FOOD_LIMIT / unitData.food_cost)
    --local unitsTotal = 1
    battleUnitsLeft[spawnSide] = unitsTotal

    sideFrames[spawnSide].icon:setTexture(unitData.icon)
    sideFrames[spawnSide].text:setText(tostring(unitsTotal))
    battleSideFrames[spawnSide]:setText("|cffffcc00" .. unitData.name .. " [" .. unitsTotal .. "]|r")

    if not unitData.is_hero and unitsUpgradesDependencies[unitData.code] ~= nil then
        for index, upgrade in ipairs(unitsUpgradesDependencies[unitData.code]) do
            local upgradeLevel = GetPlayerTechMaxAllowed(forPlayer, FourCC(upgrade.code))
            SetPlayerTechResearched(forPlayer, FourCC(upgrade.code), upgradeLevel)
            AppendUpgradeFrame(spawnSide)
            upgradeFrames[spawnSide].frames[index]:setIconPath(upgrade.icon)
            upgradeFrames[spawnSide].frames[index]:setText(upgradeLevel)
        end
    end

    local centerPointX = SPAWN_CENTER_DISTANCE * (spawnSide == SPAWN_LEFT and -1 or 1)
    local spawnAngle = spawnSide == SPAWN_LEFT and 0 or 180
    local gridPoints = generateGridForSpawn(centerPointX, spawnAngle, unitsTotal)
    local spawnedUnits = {}
    local isHeroAbilityFramesAppended = false
    for _, point in ipairs(gridPoints) do
        local unit = CreateUnit(forPlayer, FourCC(unitData.code), point.x, point.y, spawnAngle)
        unitsInBattle[unit] = spawnSide
        --RemoveGuardPosition(unit)
        GroupAddUnit(battleUnitsGroup, unit)
        GroupAddUnit(sideGroups[spawnSide], unit)
        TriggerRegisterUnitEvent(battleUnitDefeatTrg, unit, EVENT_UNIT_DEATH)
        TriggerRegisterUnitEvent(battleUnitDefeatTrg, unit, EVENT_UNIT_CHANGE_OWNER)
        table.insert(spawnedUnits, unit)
        if unitData.is_hero then
            SetHeroLevel(unit, 10, false)
            if heroAbilities[unitData.code] ~= nil then
                for abilityIndex, ability in ipairs(heroAbilities[unitData.code]) do
                    local prevLevel
                    repeat
                        prevLevel = GetUnitAbilityLevel(unit, FourCC(ability))
                        SelectHeroSkill(unit, FourCC(ability))
                    until prevLevel == GetUnitAbilityLevel(unit, FourCC(ability))
                    if not isHeroAbilityFramesAppended then
                        AppendUpgradeFrame(spawnSide)
                        upgradeFrames[spawnSide].frames[abilityIndex]:setIconPath(abilitiesIcons[ability])
                        upgradeFrames[spawnSide].frames[abilityIndex]:setText(prevLevel)
                    end
                end
            end
            isHeroAbilityFramesAppended = true
        end
        --SetWidgetLife(unit, GetUnitState(unit, UNIT_STATE_MAX_LIFE) * 0.02)
        SetUnitState(unit, UNIT_STATE_MANA, GetUnitState(unit, UNIT_STATE_MAX_MANA))
    end
    return spawnedUnits
end

function PrepareNewBattle()
    PauseTimer(sideUnitsAttackRecycleTimer)
    PauseTimer(centerCameraTimer)

    ForGroup(battleUnitsGroup, function()
        GroupRemoveUnit(battleUnitsGroup, GetEnumUnit())
        RemoveUnit(GetEnumUnit())
    end)
    local leftUnitsGroup = CreateGroup()
    GroupEnumUnitsInRect(leftUnitsGroup, GetPlayableMapRect(), nil)
    ForGroup(leftUnitsGroup, function()
        RemoveUnit(GetEnumUnit())
    end)
    GroupClear(leftUnitsGroup)
    DestroyGroup(leftUnitsGroup)

    ClearUpgradeFrames()

    EnumDestructablesInRect(GetPlayableMapRect(), TREES_FILTER, function()
        local destructable = GetEnumDestructable()
        if GetWidgetLife(destructable) <= 0.405 then
            DestructableRestoreLife(destructable, GetDestructableMaxLife(destructable), true)
        end
    end)

    local prevLeftSideData = unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex]
    local prevRightSideData = unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex]

    repeat
        rightSideSpawnData.unitIndex = rightSideSpawnData.unitIndex + 1
        repeat
            --debugPrint("New iteration")
            if unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex] == nil then
--                debugPrint("No units left in race for right side, so switch to next race")
                rightSideSpawnData.raceIndex = rightSideSpawnData.raceIndex + 1
                rightSideSpawnData.unitIndex = 1
                if unitList[rightSideSpawnData.raceIndex] == nil then
--                    debugPrint("No units left for right side, so switch unit for left side")
                    leftSideSpawnData.unitIndex = leftSideSpawnData.unitIndex + 1
                    if unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex] == nil then
--                        debugPrint("No units left in race for left side, so switch to next race")
                        leftSideSpawnData.raceIndex = leftSideSpawnData.raceIndex + 1
                        if unitList[leftSideSpawnData.raceIndex] == nil then
                            --debugPrint("All battles done")
                            ShowStatisticsFrame(prevLeftSideData.name, prevLeftSideData.history, function()
                                DelayCallback(5, function()
                                    HideStatisticsFrame(function()
                                        ShowStatisticsFrame(prevRightSideData.name, prevRightSideData.history, function()
                                            DelayCallback(5, function()
                                                HideStatisticsFrame(function()
                                                    RunFinalStatisticsFrames()
                                                end)
                                            end)
                                        end)
                                    end)
                                end)
                            end)
                            return
                        end
                        leftSideSpawnData.unitIndex = 1
                    end
                    rightSideSpawnData.raceIndex = leftSideSpawnData.raceIndex
                    rightSideSpawnData.unitIndex = leftSideSpawnData.unitIndex + 1
                end
            end
        until unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex] ~= nil
        --debugPrint("Left side - " .. leftSideSpawnData.raceIndex .. ":" .. leftSideSpawnData.unitIndex)
        local leftUnitData = unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex]
--        debugPrint("Right side - " .. rightSideSpawnData.raceIndex .. ":" .. rightSideSpawnData.unitIndex)
        local rightUnitData = unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex]
--        debugPrint("Left side name " .. leftUnitData.name)
--        debugPrint("Right side name " .. rightUnitData.name)
        local leftCanAttackRight = ((leftUnitData.attack_target.ground and rightUnitData.unit_target.ground) or (leftUnitData.attack_target.air and rightUnitData.unit_target.air)) and not (leftUnitData.attack_target.magic and rightUnitData.unit_target.immune)
--        debugPrint(leftCanAttackRight and "Left can attack right" or "Left can't attack right")
        local rightCanAttackLeft = (rightUnitData.attack_target.ground and leftUnitData.unit_target.ground) or (rightUnitData.attack_target.air and leftUnitData.unit_target.air) and not (rightUnitData.attack_target.magic and leftUnitData.unit_target.immune)
--        debugPrint(rightCanAttackLeft and "Right can attack left" or "Right can't attack left")
    until leftCanAttackRight and rightCanAttackLeft and leftUnitData.is_hero == rightUnitData.is_hero

    local leftSideUnitData = unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex]
    if prevLeftSideData ~= leftSideUnitData then
        ShowStatisticsFrame(prevLeftSideData.name, prevLeftSideData.history, function()
            DelayCallback(5, function()
                HideStatisticsFrame(function()
                    StartNewBattle()
                end)
            end)
        end)
    else
        StartNewBattle()
    end
end

function StartNewBattle()
    DelayCallback(1, function()
        local leftSideUnitData = unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex]
        local rightSideUnitData = unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex]
        local leftSideUnits = CreateUnitStack(leftSideUnitData, SPAWN_LEFT)
        local rightSideUnits = CreateUnitStack(rightSideUnitData, SPAWN_RIGHT)

        UpdateStatisticsFrames()

        battleInfoWrapperFrame:animateFadeIn(0.4, function()
            TimerStart(CreateTimer(), 3, false, function()
                battleInfoWrapperFrame:animateFadeOut(0.4)
            end)
        end)
        for _, unit in ipairs(leftSideUnits) do
            IssuePointOrder(unit, "attack", SPAWN_CENTER_DISTANCE, 0)
        end
        for _, unit in ipairs(rightSideUnits) do
            IssuePointOrder(unit, "attack", -SPAWN_CENTER_DISTANCE, 0)
        end

        TimerStart(sideUnitsAttackRecycleTimer, SIDE_UNITS_ATTACK_RECYCLE_TIMER_DURATION, false, IssueSideUnitsAttackRecycle)
        TimerStart(centerCameraTimer, CENTER_CAMERA_DURATION, true, CenterCameraOnGroups)

        CenterCameraOnGroups()
    end)
end

sideUnitsAttackRecycleTimer = CreateTimer()
SIDE_UNITS_ATTACK_RECYCLE_TIMER_DURATION = 2

function IssueUnitAttackRandomTarget(whichUnit, unitSide)
    if GetUnitCurrentOrder(whichUnit) == 0 then
        local targetUnit = GroupPickRandomUnit(sideGroups[unitSide == SPAWN_LEFT and SPAWN_RIGHT or SPAWN_LEFT])
        if targetUnit ~= nil then
            IssuePointOrder(whichUnit, "attack", GetUnitX(targetUnit), GetUnitY(targetUnit))
        end
    end
end

function IssueSideUnitsAttackRecycle()
    for _, spawnSide in ipairs({SPAWN_LEFT, SPAWN_RIGHT}) do
        ForGroup(sideGroups[spawnSide], function()
            local unit = GetEnumUnit()
            IssueUnitAttackRandomTarget(unit, spawnSide)
        end)
    end
    TimerStart(sideUnitsAttackRecycleTimer, SIDE_UNITS_ATTACK_RECYCLE_TIMER_DURATION, false, IssueSideUnitsAttackRecycle)
end

function FormatStatisticsTextFromData(unitData)
    local victoryPercentage = 0
    if unitData.battles > 0 then
        victoryPercentage = unitData.victories / unitData.battles * 100
    end
    return "Всего побеждено: " .. tostring(unitData.total_killed) .. "\nВсего потеряно: " .. tostring(unitData.total_died) .. "\nВсего битв: " .. tostring(unitData.battles) .. "\nВсего побед: " .. tostring(unitData.victories) .. " (" .. string.format("%.2f", victoryPercentage) .. "%)"
end

function UpdateStatisticsFrames()
    local leftSideUnitsData = unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex]
    local rightSideUnitsData = unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex]
    sideFrames[SPAWN_LEFT].statistics:setText(FormatStatisticsTextFromData(leftSideUnitsData))
    sideFrames[SPAWN_RIGHT].statistics:setText(FormatStatisticsTextFromData(rightSideUnitsData))
end

function BattleUnitDefeatTrgAction()
    local unit = GetTriggerUnit()
    local loserSide = unitsInBattle[unit]
    if loserSide == nil then return end
    local winnerSide = loserSide == SPAWN_LEFT and SPAWN_RIGHT or SPAWN_LEFT
    GroupRemoveUnit(sideGroups[loserSide], unit)
    local isHelper = sideHelperUnits[unit]
    if UnitAlive(unit) then
        sideHelperUnits[unit] = true
        unitsInBattle[unit] = winnerSide
        GroupAddUnit(sideGroups[winnerSide], unit)
        IssueUnitAttackRandomTarget(unit, winnerSide)
    end
    if isHelper then
        sideHelperUnits[unit] = nil
        unitsInBattle[unit] = nil
        return
    end
    battleUnitsLeft[loserSide] = battleUnitsLeft[loserSide] - 1
    sideFrames[loserSide].text:setText(tostring(battleUnitsLeft[loserSide]))
    local leftSideUnitsData = unitList[leftSideSpawnData.raceIndex].units[leftSideSpawnData.unitIndex]
    local rightSideUnitsData = unitList[rightSideSpawnData.raceIndex].units[rightSideSpawnData.unitIndex]
    local loserUnitsData = loserSide == SPAWN_LEFT and leftSideUnitsData or rightSideUnitsData
    local winnerUnitsData = loserSide == SPAWN_LEFT and rightSideUnitsData or leftSideUnitsData
    loserUnitsData.total_died = loserUnitsData.total_died + 1
    winnerUnitsData.total_killed = winnerUnitsData.total_killed + 1
    if not isWinningFrameAppearing and battleUnitsLeft[loserSide] <= 0 then
        loserUnitsData.battles = loserUnitsData.battles + 1
        winnerUnitsData.battles = winnerUnitsData.battles + 1
        winnerUnitsData.victories = winnerUnitsData.victories + 1
        isWinningFrameAppearing = true
        ForGroup(sideGroups[winnerSide], function()
            if GetUnitCurrentOrder(GetEnumUnit()) ~= 0 then
                IssueImmediateOrder(GetEnumUnit(), "stop")
            end
        end)
        battleWinnerTextFrame:setText("|cffffcc00ПОБЕДИТЕЛЬ|r\n\n" .. winnerUnitsData.name)
        PlayInterfaceSound(SOUND_INTERFACE_BATTLE_COMPLETED)
        battleWinnerBackdropFrame.cover:setVisible(true):animateSize(0.75, nil, 0.3, nil, nil, function()
            DelayCallback(2.5, function()
                battleWinnerTextFrame:animateFadeOut(0.75)
                battleWinnerBackdropFrame.cover:animateSize(1.25, nil, 0, nil, nil, function()
                    battleWinnerBackdropFrame.cover:setVisible(false)
                    DelayCallback(1, function()
                        table.insert(loserUnitsData.history, {
                            enemy = winnerUnitsData,
                            units_left = battleUnitsLeft[winnerSide],
                            is_winner = false
                        })
                        table.insert(winnerUnitsData.history, {
                            enemy = loserUnitsData,
                            units_left = battleUnitsLeft[winnerSide],
                            is_winner = true
                        })
                        isWinningFrameAppearing = false
                        PrepareNewBattle()
                    end)
                end)
            end)
        end)
        DelayCallback(0.35, function()
            battleWinnerTextFrame:animateFadeIn(0.4)
        end)
    end
    if not isHelper then
        unitsInBattle[unit] = nil
    end
    UpdateStatisticsFrames()
    --debugPrint("Left on side " .. unitSide .. ": " .. battleUnitsLeft[unitSide])
end

function BattleUnitSummonHelperAction()
    local summonerUnit = GetSummoningUnit()
    local unitSide = unitsInBattle[summonerUnit]
    if unitSide == nil then return end
    local summonedUnit = GetTriggerUnit()
    if summonedUnit == nil then return end
    sideHelperUnits[summonedUnit] = true
    unitsInBattle[summonedUnit] = unitSide
    GroupAddUnit(sideGroups[unitSide], summonedUnit)
    GroupAddUnit(battleUnitsGroup, summonedUnit)
    DelayCallback(1, function()
        IssueUnitAttackRandomTarget(summonedUnit, unitSide)
    end)
end

function BattleUnitSpellsBehaviorAction()
    local unit = GetTriggerUnit()
    local spellId = GetSpellAbilityId()
    if GetUnitCurrentOrder(unit) == OrderId("uncorporealform") then
        DelayCallback(10, function()
            IssueImmediateOrder(unit, "corporealform")
            BlzUnitDisableAbility(unit, spellId, true, false)
            DelayCallback(15, function()
                if UnitAlive(unit) then
                    BlzUnitDisableAbility(unit, spellId, false, false)
                end
            end)
        end)
    elseif GetSpellAbilityId() == FourCC('AOwk') then
        DelayCallback(math.random(3, 7), function()
            if UnitAlive(unit) then
                local unitSide = unitsInBattle[unit]
                if unitSide == nil then return end
                local targetUnit = GroupPickRandomUnit(sideGroups[unitSide == SPAWN_LEFT and SPAWN_RIGHT or SPAWN_LEFT])
                if targetUnit ~= nil then
                    RemoveGuardPosition(unit) -- AI prevents to attack unit in windwalk even if do it manually
                    IssueTargetOrder(unit, "attack", targetUnit)
                    local timer = CreateTimer()
                    TimerStart(timer, 0.25, true, function()
                        if GetUnitAbilityLevel(unit, FourCC('BOwk')) == 0 then
                            RecycleGuardPosition(unit)
                            PauseTimer(timer)
                            DestroyTimer(timer)
                        elseif GetUnitCurrentOrder(unit) == 0 then
                            if not UnitAlive(targetUnit) then
                                targetUnit = GroupPickRandomUnit(sideGroups[unitSide == SPAWN_LEFT and SPAWN_RIGHT or SPAWN_LEFT])
                            end
                            RemoveGuardPosition(unit)
                            IssueTargetOrder(unit, "attack", targetUnit)
                        end
                    end)
                end
            end
        end)
    end
end

centerCameraTimer = CreateTimer()
panningCamera = CreateCameraSetup()
CENTER_CAMERA_DURATION = 0.5
PANNING_CAMERA_FOV_X = 70.0
PANNING_CAMERA_ANGLE_OF_ATTACK = 304.0

function CenterCameraOnGroups()
    local minX = 99999
    local maxX = -99999
    local minY = 99999
    local maxY = -99999
    local haveUnits = false
    for _, sideGroup in ipairs(sideGroups) do
        ForGroup(sideGroup, function()
            haveUnits = true
            local unit = GetEnumUnit()
            minX = math.min(minX, GetUnitX(unit))
            maxX = math.max(maxX, GetUnitX(unit))
            minY = math.min(minY, GetUnitY(unit))
            maxY = math.max(maxY, GetUnitY(unit))
        end)
    end
    local centerX = 0.0
    local centerY = 0.0
    local distance = 1650.0
    if haveUnits then
        centerX = (maxX + minX) / 2
        centerY = (maxY + minY) / 2
        local width = maxX - minX
        local height = (maxY - minY) * math.cos(math.rad(PANNING_CAMERA_ANGLE_OF_ATTACK - 270))
        local fovY = math.deg(2 * math.atan(math.tan(math.rad(PANNING_CAMERA_FOV_X / 2)) / math.sqrt((BlzGetLocalClientWidth() / BlzGetLocalClientHeight()) ^ 2 + 1)))
        local distanceWidth = width / (2 * math.tan(math.rad(PANNING_CAMERA_FOV_X / 2)))
        local distanceHeight = height / (2 * math.tan(math.rad(fovY / 2)))
        distance = math.max(distanceWidth, distanceHeight, 1000) * 1.15
    end

    CameraSetupSetField(panningCamera, CAMERA_FIELD_TARGET_DISTANCE, distance, 0.0)
    CameraSetupSetDestPosition(panningCamera, centerX, centerY, 0.0)
    CameraSetupApplyForceDuration(panningCamera, true, CENTER_CAMERA_DURATION)
end

function TreeDiesAction()
    local destructable = GetDyingDestructable()
    DelayCallback(TREE_RESTORE_DELAY, function()
        if GetWidgetLife(destructable) <= 0.405 then
            DestructableRestoreLife(destructable, GetDestructableMaxLife(destructable), true)
        end
    end)
end

function ToggleMouseCursorAction()
    isCursorEnabled = not isCursorEnabled
    BlzEnableCursor(isCursorEnabled)
end

OnInit.map(function()
    FogEnable(false)
    FogMaskEnable(false)
    SetCameraPosition(0, 0)
    SetTimeOfDay(12)
    SuspendTimeOfDay(true)
    EndThematicMusic()
    ClearMapMusic()
    VolumeGroupSetVolume(SOUND_VOLUMEGROUP_AMBIENTSOUNDS, 0)
    BlzEnableCursor(isCursorEnabled)
    SetPlayerAlliance(Player(1), Player(0), ALLIANCE_SHARED_VISION, true)
    SetPlayerAlliance(Player(2), Player(0), ALLIANCE_SHARED_VISION, true)
    SetPlayerHandicap(Player(1), 0.05)
    SetPlayerHandicap(Player(2), 0.05)
    --SetPlayerAlliance(Player(1), Player(0), ALLIANCE_SHARED_CONTROL, true)
    --SetPlayerAlliance(Player(2), Player(0), ALLIANCE_SHARED_CONTROL, true)

    sideFrames = {
        [SPAWN_LEFT] = {
            icon = leftSideIconFrame,
            text = leftSideTextFrame,
            statistics = leftSideStatisticsTextFrame,
        },
        [SPAWN_RIGHT] = {
            icon = rightSideIconFrame,
            text = rightSideTextFrame,
            statistics = rightSideStatisticsTextFrame,
        }
    }
    battleSideFrames = {
        [SPAWN_LEFT] = battleInfoLeftSideTitleFrame,
        [SPAWN_RIGHT] = battleInfoRightSideTitleFrame
    }

    CameraSetupSetField(panningCamera, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_ROTATION, 90.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_ANGLE_OF_ATTACK, PANNING_CAMERA_ANGLE_OF_ATTACK, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_TARGET_DISTANCE, 1650.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_ROLL, 0.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_FIELD_OF_VIEW, PANNING_CAMERA_FOV_X, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_FARZ, 5000.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    CameraSetupSetField(panningCamera, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    CameraSetupSetDestPosition(panningCamera, 0, 0, 0.0)

    --local unit = CreateUnit(Player(0), FourCC('Ekee'), 0, 0, 0)
    --SetHeroLevel(unit, 10, false)
    --for _, ability in ipairs(heroAbilities['Ekee']) do
    --    repeat
    --        local prevLevel = GetUnitAbilityLevel(unit, FourCC(ability))
    --        SelectHeroSkill(unit, FourCC(ability))
    --    until prevLevel == GetUnitAbilityLevel(unit, FourCC(ability))
    --end

    battleUnitDefeatTrg = CreateTrigger()
    TriggerAddAction(battleUnitDefeatTrg, BattleUnitDefeatTrgAction)

    battleUnitHelperSummonTrg = CreateTrigger()
    TriggerRegisterPlayerUnitEvent(battleUnitHelperSummonTrg, Player(1), EVENT_PLAYER_UNIT_SUMMON)
    TriggerRegisterPlayerUnitEvent(battleUnitHelperSummonTrg, Player(2), EVENT_PLAYER_UNIT_SUMMON)
    TriggerAddAction(battleUnitHelperSummonTrg, BattleUnitSummonHelperAction)

    battleUnitTemporaryDisableSpiritFormTrg = CreateTrigger()
    TriggerRegisterPlayerUnitEvent(battleUnitTemporaryDisableSpiritFormTrg, Player(1), EVENT_PLAYER_UNIT_SPELL_EFFECT)
    TriggerRegisterPlayerUnitEvent(battleUnitTemporaryDisableSpiritFormTrg, Player(2), EVENT_PLAYER_UNIT_SPELL_EFFECT)
    TriggerAddAction(battleUnitTemporaryDisableSpiritFormTrg, BattleUnitSpellsBehaviorAction)

    treeDiesTrg = CreateTrigger()
    EnumDestructablesInRect(GetPlayableMapRect(), TREES_FILTER, function()
        TriggerRegisterDeathEvent(treeDiesTrg, GetEnumDestructable())
    end)
    TriggerAddAction(treeDiesTrg, TreeDiesAction)

    toggleMouseCursorTrg = CreateTrigger()
    --BlzTriggerRegisterPlayerKeyEvent(toggleMouseCursorTrg, Player(0), OSKEY_F, 0, true)
    TriggerRegisterPlayerEvent(toggleMouseCursorTrg, Player(0), EVENT_PLAYER_END_CINEMATIC)
    TriggerAddAction(toggleMouseCursorTrg, ToggleMouseCursorAction)
end)

function RunFinalStatisticsFrames()
    for _, side in ipairs(sideFrames) do
        side.icon.cover:animateFadeOut(0.75)
        side.text:animateFadeOut(0.75)
        side.statistics:animateFadeOut(0.75)
    end
    DelayCallback(0.5, function()
        local flatUnitNotHeroList = {}
        local flatUnitHeroList = {}
        for _, raceUnits in ipairs(unitList) do
            for _, unit in ipairs(raceUnits.units) do
                local victoryPercentage = 0
                if unit.battles > 0 then
                    victoryPercentage = unit.victories / unit.battles
                end
                unit.victoryPercentage = victoryPercentage
                if unit.is_hero then
                    table.insert(flatUnitHeroList, unit)
                else
                    table.insert(flatUnitNotHeroList, unit)
                end
            end
        end
        local topUnitHeroList = {table.unpack(flatUnitHeroList)}
        table.sort(topUnitHeroList, function(a, b)
            return a.victoryPercentage > b.victoryPercentage
        end)
        topUnitHeroList = {table.unpack(topUnitHeroList, 1, 5)}
        local worstUnitHeroList = {table.unpack(flatUnitHeroList)}
        table.sort(worstUnitHeroList, function(a, b)
            return a.victoryPercentage < b.victoryPercentage
        end)
        worstUnitHeroList = {table.unpack(worstUnitHeroList, 1, 5)}
        local topUnitNotHeroList = {table.unpack(flatUnitNotHeroList)}
        table.sort(topUnitNotHeroList, function(a, b)
            return a.victoryPercentage > b.victoryPercentage
        end)
        topUnitNotHeroList = {table.unpack(topUnitNotHeroList, 1, 5)}
        local worstUnitNotHeroList = {table.unpack(flatUnitNotHeroList)}
        table.sort(worstUnitNotHeroList, function(a, b)
            return a.victoryPercentage < b.victoryPercentage
        end)
        worstUnitNotHeroList = {table.unpack(worstUnitNotHeroList, 1, 5)}
        ShowFinalRacesFrame(unitList, function()
            DelayCallback(15, function()
                totalBattlesStatisticsRacesWrapperFrame:animateFadeOut(1.5, function()
                    ShowFinalTopsFrame({topUnitNotHeroList, worstUnitNotHeroList}, {topUnitHeroList, worstUnitHeroList})
                    DelayCallback(15, function()
                        totalBattlesStatisticsTopsWrapperFrame:animateFadeOut(1.5)
                        DelayCallback(1, function()
                            totalBattlesStatisticsBackdropFrame.cover:animateFadeOut(1.5, function()
                                EndGame(false)
                            end)
                        end)
                    end)
                end)
            end)
        end)
    end)
end

OnInit.final(function()
    --DelayCallback(0.1, function()
    --    for _, leftRaceUnits in ipairs(unitList) do
    --        for _, leftUnitData in ipairs(leftRaceUnits.units) do
    --            for _, rightRaceUnits in ipairs(unitList) do
    --                for _, rightUnitData in ipairs(rightRaceUnits.units) do
    --                    if leftUnitData ~= rightUnitData then
    --                        local pushEntry = true
    --                        for _, history in ipairs(leftUnitData.history) do
    --                            if rightUnitData == history.enemy then
    --                                pushEntry = false
    --                                break
    --                            end
    --                        end
    --                        if pushEntry then
    --                            local isWinner = math.random(1, 2) == 1
    --                            local unitsLeft = math.random(1, 100)
    --                            leftUnitData.battles = leftUnitData.battles + 1
    --                            rightUnitData.battles = rightUnitData.battles + 1
    --                            leftUnitData.victories = leftUnitData.victories + (isWinner and 1 or 0)
    --                            rightUnitData.victories = rightUnitData.victories + (not isWinner and 1 or 0)
    --                            table.insert(leftUnitData.history, {
    --                                enemy = rightUnitData,
    --                                units_left = unitsLeft,
    --                                is_winner = isWinner
    --                            })
    --                            table.insert(rightUnitData.history, {
    --                                enemy = leftUnitData,
    --                                units_left = unitsLeft,
    --                                is_winner = not isWinner
    --                            })
    --                        end
    --                    end
    --                end
    --            end
    --        end
    --    end
    --    RunFinalStatisticsFrames()
    --end)
    DelayCallback(1, function()
        PrepareNewBattle()
        for _, side in ipairs({SPAWN_LEFT, SPAWN_RIGHT}) do
            for _, frame in ipairs(upgradeFrames[side].frames) do
                frame:setVisible(false)
            end
        end
        DelayCallback(1.25, function()
            for index, side in ipairs(sideFrames) do
                side.icon.cover:animateFadeIn(0.75)
                side.text:animateFadeIn(0.75)
                side.statistics:animateFadeIn(0.75)
                for _, frame in ipairs(upgradeFrames[index].frames) do
                    frame:animateFadeIn(0.75)
                end
            end
        end)
    end)
end)